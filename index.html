use std::{thread, time::Duration, env, sync::Arc, sync::atomic::{AtomicBool, Ordering}};
use reqwest::blocking::Client;
use serde::{Deserialize, Serialize};
use enigo::{Enigo, Key, Keyboard, Mouse, Button, Direction, Settings, Axis};
use chrono::Local;

const DEFAULT_FIREBASE_URL: &str = "https://key-board-ee542-default-rtdb.firebaseio.com";
const DEFAULT_ROOM_ID: &str = "test";
const POLL_INTERVAL_MS: u64 = 30;

#[derive(Deserialize, Debug)]
struct InputData {
    #[serde(rename = "type")]
    kind: String,
    key: Option<String>,
    time: u64,
    text: Option<String>,
    x: Option<i32>,
    y: Option<i32>,
    dx: Option<i32>,
    dy: Option<i32>,
    delta: Option<i32>,
    count: Option<u32>,
    button: Option<String>,
}

#[derive(Serialize)]
struct StatusData {
    online: bool,
    last_seen: u64,
    version: String,
}

fn main() {
    println!("ðŸŽ¹ Remote Keyboard Pro èµ·å‹•");
    
    let firebase_url = env::var("FIREBASE_URL")
        .unwrap_or_else(|_| DEFAULT_FIREBASE_URL.to_string());
    let room_id = env::var("ROOM_ID")
        .unwrap_or_else(|_| DEFAULT_ROOM_ID.to_string());

    let client = Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .expect("HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å¤±æ•—");

    let settings = Settings::default();
    let mut enigo = Enigo::new(&settings).expect("EnigoåˆæœŸåŒ–å¤±æ•—");
    let mut last_time = 0u64;
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        println!("\n\nçµ‚äº†ã‚·ã‚°ãƒŠãƒ«å—ä¿¡...");
        r.store(false, Ordering::SeqCst);
    }).expect("Ctrl+Cãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®šå¤±æ•—");

    println!("Room: {}", room_id);
    println!("Version: 2.0");
    println!("ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹...\n");

    let status_client = client.clone();
    let status_url = format!("{}/rooms/{}/status.json", firebase_url, room_id);
    thread::spawn(move || {
        loop {
            let status = StatusData {
                online: true,
                last_seen: current_timestamp(),
                version: "2.0".to_string(),
            };
            let _ = status_client.put(&status_url).json(&status).send();
            thread::sleep(Duration::from_secs(5));
        }
    });

    let mut command_count = 0u32;

    while running.load(Ordering::SeqCst) {
        let url = format!("{}/rooms/{}/input.json", firebase_url, room_id);
        
        match client.get(&url).send() {
            Ok(resp) => {
                match resp.text() {
                    Ok(text) => {
                        if text != "null" && !text.is_empty() {
                            match serde_json::from_str::<InputData>(&text) {
                                Ok(data) => {
                                    if data.time > last_time {
                                        last_time = data.time;
                                        handle_input(&mut enigo, &data);
                                        command_count += 1;
                                    }
                                }
                                Err(e) => eprintln!("[{}] JSONè§£æžã‚¨ãƒ©ãƒ¼: {}", timestamp(), e),
                            }
                        }
                    }
                    Err(e) => eprintln!("[{}] ãƒ¬ã‚¹ãƒãƒ³ã‚¹èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {}", timestamp(), e),
                }
            }
            Err(e) => eprintln!("[{}] ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {}", timestamp(), e),
        }

        thread::sleep(Duration::from_millis(POLL_INTERVAL_MS));
    }

    println!("\nçµ±è¨ˆ: å®Ÿè¡Œã‚³ãƒžãƒ³ãƒ‰æ•°: {}", command_count);
    println!("çµ‚äº†ã—ã¾ã—ãŸã€‚");
}

fn handle_input(enigo: &mut Enigo, data: &InputData) {
    match data.kind.as_str() {
        "char" => {
            if let Some(ref key_str) = data.key {
                let _ = enigo.text(key_str);
                println!("[{}] å…¥åŠ›: {}", timestamp(), key_str);
            }
        }
        "text" => {
            if let Some(ref text) = data.text {
                let _ = enigo.text(text);
                println!("[{}] ãƒ†ã‚­ã‚¹ãƒˆ: {}æ–‡å­—", timestamp(), text.len());
            }
        }
        "enter" => {
            let _ = enigo.key(Key::Return, Direction::Click);
            println!("[{}] Enter", timestamp());
        }
        "backspace" => {
            let count = data.count.unwrap_or(1);
            for _ in 0..count {
                let _ = enigo.key(Key::Backspace, Direction::Click);
            }
            println!("[{}] Backspace Ã— {}", timestamp(), count);
        }
        "delete" => {
            let _ = enigo.key(Key::Delete, Direction::Click);
            println!("[{}] Delete", timestamp());
        }
        "tab" => {
            let _ = enigo.key(Key::Tab, Direction::Click);
            println!("[{}] Tab", timestamp());
        }
        "escape" => {
            let _ = enigo.key(Key::Escape, Direction::Click);
            println!("[{}] Escape", timestamp());
        }
        "ime" => {
            let _ = enigo.key(Key::Alt, Direction::Press);
            let _ = enigo.key(Key::Space, Direction::Click);
            let _ = enigo.key(Key::Alt, Direction::Release);
            println!("[{}] IMEåˆ‡æ›¿", timestamp());
        }
        "arrow_up" => {
            let _ = enigo.key(Key::UpArrow, Direction::Click);
            println!("[{}] â†‘", timestamp());
        }
        "arrow_down" => {
            let _ = enigo.key(Key::DownArrow, Direction::Click);
            println!("[{}] â†“", timestamp());
        }
        "arrow_left" => {
            let _ = enigo.key(Key::LeftArrow, Direction::Click);
            println!("[{}] â†", timestamp());
        }
        "arrow_right" => {
            let _ = enigo.key(Key::RightArrow, Direction::Click);
            println!("[{}] â†’", timestamp());
        }
        "ctrl_c" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('c'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            println!("[{}] Ctrl+C", timestamp());
        }
        "ctrl_v" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('v'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            println!("[{}] Ctrl+V", timestamp());
        }
        "ctrl_x" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('x'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            println!("[{}] Ctrl+X", timestamp());
        }
        "ctrl_z" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('z'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            println!("[{}] Ctrl+Z", timestamp());
        }
        "ctrl_a" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('a'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            println!("[{}] Ctrl+A", timestamp());
        }
        "mouse_move_relative" => {
            if let (Some(dx), Some(dy)) = (data.dx, data.dy) {
                let _ = enigo.move_mouse(dx, dy, enigo::Coordinate::Rel);
                println!("[{}] ãƒžã‚¦ã‚¹ç›¸å¯¾ç§»å‹•: ({}, {})", timestamp(), dx, dy);
            }
        }
        "mouse_click" => {
            let button = match data.button.as_deref() {
                Some("left") => Button::Left,
                Some("right") => Button::Right,
                Some("middle") => Button::Middle,
                _ => Button::Left,
            };
            let _ = enigo.button(button, Direction::Click);
            println!("[{}] ã‚¯ãƒªãƒƒã‚¯: {:?}", timestamp(), button);
        }
        "mouse_scroll" => {
            if let Some(delta) = data.delta {
                let _ = enigo.scroll(delta, Axis::Vertical);
                println!("[{}] ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«: {}", timestamp(), delta);
            }
        }
        "clear_all" => {
            let _ = enigo.key(Key::Control, Direction::Press);
            let _ = enigo.key(Key::Unicode('a'), Direction::Click);
            let _ = enigo.key(Key::Control, Direction::Release);
            thread::sleep(Duration::from_millis(50));
            let _ = enigo.key(Key::Backspace, Direction::Click);
            println!("[{}] å…¨å‰Šé™¤", timestamp());
        }
        _ => {
            eprintln!("[{}] ä¸æ˜Ž: {}", timestamp(), data.kind);
        }
    }
}

fn timestamp() -> String {
    Local::now().format("%H:%M:%S").to_string()
}

fn current_timestamp() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
}
